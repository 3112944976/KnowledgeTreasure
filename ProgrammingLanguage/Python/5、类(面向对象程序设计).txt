1、面向对象程序设计的诞生初衷
	一般设计程序的思路为自上向下的非线性树状逻辑结构，这种设计思路害怕对程序部分功能进行改变时，会影响整体的程序逻辑结构。
2、面向对象程序设计的优点
	1.软件设计更加灵活
	2.能很好的支持代码的复用和设计复用
	3.代码具有更好的可读性和可扩展性，大幅降低了软件开发的难度
3、面向对象程序设计的关键性观念
	将数据以及对数据的操作封装在一起，组成一个相互依存、不可分割的整体（对象）。而这种具有共同特征的对象集又形成了类。同时开发的思路是，将一个大的工程按照功能需求来定义多个类来完成。
4、面向对象程序设计的关键
	如何合理地定义这些类并且组织多个类之间的关系。
5、重要的名词定义
	1.数据成员：创建类时，用变量表示对象特征的成员。
	# 对象对内封装属性，用变量形式表示。
	2.成员方法:用函数形式表示对象行为的成员。

6、类的定义和使用（P129）
	1.isinstance(car,[类名])  # 测试一个对象是否为类的实例
	2.[类名]._ _doc_ _  # 查看类的帮助文档

*7、私有、公有成员
#  . 是成员访问运算符
#  _ _xxx_ _:系统定义的特殊成员
#  _xxx:保护成员（P130）
	1.私有成员（函数及变量皆可为私有成员）在类的外部不能直接访问，但可以通过使用类中已经定义的方法来间接访问，同样也必须要通过类中已经编写好的方法来实现对私有成员的修改。
		私有成员命名样式：若成员名“是以两个（或两个以上）_开头，且不以两个（或两个以上）_结尾来命名的”则其为私有成员。
		在类外部访问方法：[实例化对象名]._[类名]_ _xxx
	2.共有成员在类的外部可以直接被访问。
		在类外部访问方法：[实例化对象名].xxx

8、在类的外部给类添加函数或者方法（函数和方法是有区别的）：（P131）
9、成员方法：
	1.成员方法的种类：（P132）
	# 1.2.5是属于对象的实例方法
	# 所有的实例方法都必须至少有一个名为self的参数，且必须是方法的第一个形参。
	# 静态及类方法都可以通过类名和对象名来调用，但不能直接访问属于对象的成员，只能访问属于类的成员。
	# 编写这些特殊方法（类、静态、抽象方法）的原理都是修饰器函数的编写样式，需要先@{classmathod/staticmethod/abc.abstractmethod}
	   他们也不属于任何实例
		1.共有方法
		2.私有方法
		3.静态方法（需要修饰器）
		# 静方法可以不接受任何参数
		4.类方法（需要修饰器）
		# 一般以cls作为第一个参数来表示该类滋生
		5.抽象方法（需要修饰器）
		# 其一般定义在抽象类中，并且要求派生类必须重新实现
*10、属性（P133-135）
	1.属性诞生的原因：（P133最下方的段落：有效监控用户进行修改时提供的新数据的合法性，保证类的高封装性。）
	2.属性的定义：
		属性是一种特殊的成员方法，结合了公开数据成员和成员方法的优点，使得：
		既可以像成员方法那样对值进行必要的检查，又可以像数据成员那样被灵活的访问。
	3.编写属性的原理：
		修饰器函数编写原理，编写时针对的value是构造方法中‘self._ _value’的value。
	4.编写属性具体操作：（P134-135）
11、类与成员的动态性：（P136：可以动态的为自定义类及其对象增加新的属性和行为，这俗称为“混入机制”。）
12、继承：（P137-138）
# 派生类可以继承父类的共有成员，但不能继承私有成员。
	1.工作原理:
		设计一个新类时，可以继承一个已有的设计良好的类然后进行二次开发。
	2.优点:
		大幅度减少开发高质量，且能大程度的保证质量。
	3.常用名词：
		已有的原类称为：父类，基类
		派生的新类称为:  子类，派生类
	4.在派生类中调用父类的方法：
		1.super(子类名，self).__init__([要加载的父类参数表])
		2.[父类名].__init__(self, [要加载的父类参数表])
		3.‘基类名.方法名（）
13、多态（P139）
	1.定义：
		基类的同一个方法在不同派生类对象中具有不同的表现二和行为。
	2.工作原理：
		使用了继承的方法，在子类中重写了父类中的方法，会出现覆盖现象。
14、特殊方法和运算符重载（P139-141）
	1.特殊方法：
	# Python自动提供一个默认的析构和构造方法进行必要的操作，因此可以不写入这些特殊方法。
		1._ _init_ _( ):用来为数据成员设置初始值或者进行其他必要的初始化操作。
		2._ _def_ _( ):用来自动释放对象占用的资源。
	2.运算符重载：
		1.目的：在类中可重新写入一个自定义化或者重载的符合实际任务需求的运算符功能。
