1、关于形参的默认值参数如果是可变数据类型，当多次调用默认值参数的时候，该可变默认值参数会具有记忆性。如果不使用默认值参数的话，就不会出现这样的问题。
--->总结：如果我们的实参或者形参是可变的数据类型，那么我们在函数内对该参数的一系列修改，都将具有记忆性。
2、*及**具有对实参序列解包（脱容器），对形参接受未知长度的实参的功能。其中*会以tuple的形式来组织值，**会以dict的形式来组织值。
3、关键参数指的是在函数的调用过程中，形如：f(x = 7, y = 0)中 x = 7 这样的样式。
4、形式参数则比较正常了，形如:f(7,0)
5、常见的电池函数(其参数f可以使用lambda表达式来编写):
1>filter(f, iteral)
2>map(f, iteral)
3>reduce(f, iteral)
----------------------------------
6、《偏函数》
1>导入模块：
import functools
2>对变量a的函数化改造（1.赋予其一个相应功能函数的函数名2.固定该功能函数的右参数,即y）：
a = functools.partial(fun, y)
3>可以自定义或者直接实用模块中的功能函数：
fun(x, y)
4>之后我们可以把变量a当函数名来使用了
a(x)

7、《生成器函数》
'''含有yield的函数都是生成器函数'''
1>yield含有断点（输出其后的值后会记忆位置，下次再实用该函数时会从记忆的位置开始运行）、截距（输出其后的值，会将该值打包带走，可能会干扰到相关赋值等操作）、输出的功能。
2>生成器函数f(x)是无根的浮萍，如果f(x)没有内部定义yield循环的次数，则必须再另外定义一个执行函数给g()编写循环来规定执行yield的次数。而调用f(x)的步骤是：a = g() print(next(a)/a._ _next_ _)

8、《修饰器函数》
1>定义修饰器函数：
def f(func):
       print()
       def ff(*x):  # 若被绑定的函数g是带有参数的函数，则函数ff并不可少。
              print("正在调用函数:", func.__name__)
              return func
       return ff()/f()
2>修饰器的向下绑定：
@f
3>编写被绑定的函数：
def g(*x)/g():
       return ...
4>调用函数g(*x)/g():
g()/g(1,2,3... ...)

9、《函数的递归》
1>eg1:
	def f(x):
      	        ... ...
       	       return x[0] + f(x[1:])